"""Redesign of Image Models

Revision ID: 37256df44112
Revises: 4da10b980a5c
Create Date: 2024-01-03 17:29:09.760782

"""
import asyncio
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql
from sqlalchemy.ext.asyncio import AsyncSession
from yadisk.exceptions import PathNotFoundError

from app.db import async_session_maker
from app.repos.SQLAlchemy_repository import SQLAlchemyRepository
from app.services.cloud_storage import CloudStorageService

# revision identifiers, used by Alembic.
revision: str = "37256df44112"
down_revision: Union[str, None] = "4da10b980a5c"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "image",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column(
            "image_url", sa.String(), nullable=False, server_default=sa.text("'absent'")
        ),
        sa.Column(
            "public_key",
            sa.String(),
            nullable=False,
            server_default=sa.text("'absent'"),
        ),
        sa.Column(
            "file_path", sa.String(), nullable=False, server_default=sa.text("'absent'")
        ),
        sa.Column(
            "discriminator",
            sa.String(),
            nullable=False,
            server_default=sa.text("'artwork_image'"),
        ),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("image_url"),
    )
    op.create_index(op.f("ix_image_id"), "image", ["id"], unique=False)

    # ### После создания новой таблицы image ###
    # Копируем данные из artwork_image в image
    op.execute(
        "INSERT INTO image (id, image_url, created_at) SELECT id, image_url, created_at FROM artwork_image"
    )

    op.drop_constraint("artwork_images_image_url_key", "artwork_image", type_="unique")
    op.drop_index("ix_artwork_image_id", table_name="artwork_image")
    op.create_foreign_key(None, "artwork_image", "image", ["id"], ["id"])

    # Обновите значение поля artwork_id в artwork_image на основе существующих данных
    # op.execute('UPDATE artwork_image SET artwork_id = (SELECT id FROM image WHERE image.id = artwork_image.id)')

    op.drop_column("artwork_image", "image_url")
    op.drop_column("artwork_image", "created_at")
    # ### end Alembic commands ###

    # ИСПОЛЬЗУЕТСЯ ДЛЯ СОЗДАНИЯ ПОЛЕЙ (public_key & file_path) УЖЕ СОЗДАННЫХ ОБЪЕКТОВ
    asyncio.run(update_images_fields())


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column(
        "artwork_image",
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=False,
        ),
    )
    op.add_column(
        "artwork_image",
        sa.Column("image_url", sa.VARCHAR(), autoincrement=False, nullable=False),
    )
    op.drop_constraint(None, "artwork_image", type_="foreignkey")
    op.create_index("ix_artwork_image_id", "artwork_image", ["id"], unique=False)
    op.create_unique_constraint(
        "artwork_images_image_url_key", "artwork_image", ["image_url"]
    )
    op.drop_index(op.f("ix_image_id"), table_name="image")
    op.drop_table("image")
    # ### end Alembic commands ###


async def update_images_fields():
    # TODO: Сделать алгоритм поиска файла по image_url внутри НЕ публичного дискового пространства и заменять ещё file_path
    session: AsyncSession = async_session_maker()
    from app.modules.cloud_storage.models import Image

    repo = SQLAlchemyRepository(session=session)
    repo.model = Image

    images = await repo.get_all()
    print(images)
    for image in images:
        try:
            image_data = await CloudStorageService().get_file_info(
                image.image_url
            )
            print(image_data)
            public_key = image_data.FIELDS.get("public_key")  # noqa

            file_path = None

            image.public_key = public_key
        except PathNotFoundError:
            continue

    await session.commit()
    await session.close()


if __name__ == "__main__":
    asyncio.run(update_images_fields())
